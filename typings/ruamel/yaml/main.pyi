"""
This type stub file was generated by pyright.
"""

from pathlib import Path
from types import TracebackType
from typing import Any, Optional, Union

from _ruamel_yaml import CEmitter
from ruamel.yaml.compat import StreamTextType, StreamType, VersionType, with_metaclass
from ruamel.yaml.constructor import Constructor
from ruamel.yaml.dumper import *
from ruamel.yaml.events import *
from ruamel.yaml.nodes import *
from ruamel.yaml.representer import Representer
from ruamel.yaml.tokens import *

if False: ...

class YAML:
    def __init__(
        self: Any,
        *,
        typ: Optional[Union[list[str], str]] = ...,
        pure: Any = ...,
        output: Any = ...,
        plug_ins: Any = ...,
    ) -> None:
        """
        typ: 'rt'/None -> RoundTripLoader/RoundTripDumper,  (default)
             'safe'    -> SafeLoader/SafeDumper,
             'unsafe'  -> normal/unsafe Loader/Dumper (pending deprecation)
             'full'    -> full Dumper only, including python built-ins that are
                          potentially unsafe to load
             'base'    -> baseloader
        pure: if True only use Python modules
        input/output: needed to work as context manager
        plug_ins: a list of plug-in files
        """
        ...

    @property
    def reader(self) -> Any: ...
    @property
    def scanner(self) -> Any: ...
    @property
    def parser(self) -> Any: ...
    @property
    def composer(self) -> Any: ...
    @property
    def constructor(self) -> Any: ...
    @property
    def resolver(self) -> Any: ...
    @property
    def emitter(self) -> Any: ...
    @property
    def serializer(self) -> Any: ...
    @property
    def representer(self) -> Any: ...
    def scan(self, stream: StreamTextType) -> Any:
        """
        Scan a YAML stream and produce scanning tokens.
        """
        ...

    def parse(self, stream: StreamTextType) -> Any:
        """
        Parse a YAML stream and produce parsing events.
        """
        ...

    def compose(self, stream: Union[Path, StreamTextType]) -> Any:
        """
        Parse the first YAML document in a stream
        and produce the corresponding representation tree.
        """
        ...

    def compose_all(self, stream: Union[Path, StreamTextType]) -> Any:
        """
        Parse all YAML documents in a stream
        and produce corresponding representation trees.
        """
        ...

    def load(self, stream: Union[Path, StreamTextType]) -> Any:
        """
        at this point you either have the non-pure Parser (which has its own reader and
        scanner) or you have the pure Parser.
        If the pure Parser is set, then set the Reader and Scanner, if not already set.
        If either the Scanner or Reader are set, you cannot use the non-pure Parser,
            so reset it to the pure parser and set the Reader resp. Scanner if necessary
        """
        ...

    def load_all(self, stream: Union[Path, StreamTextType]) -> Any: ...
    def get_constructor_parser(self, stream: StreamTextType) -> Any:
        """
        the old cyaml needs special setup, and therefore the stream
        """
        ...

    def emit(self, events: Any, stream: Any) -> None:
        """
        Emit YAML parsing events into a stream.
        If stream is None, return the produced string instead.
        """
        ...

    def serialize(self, node: Any, stream: Optional[StreamType]) -> Any:
        """
        Serialize a representation tree into a YAML stream.
        If stream is None, return the produced string instead.
        """
        ...

    def serialize_all(self, nodes: Any, stream: Optional[StreamType]) -> Any:
        """
        Serialize a sequence of representation trees into a YAML stream.
        If stream is None, return the produced string instead.
        """
        ...

    def dump(
        self: Any,
        data: Union[Path, StreamType],
        stream: Any = ...,
        *,
        transform: Any = ...,
    ) -> Any: ...
    def dump_all(
        self, documents: Any, stream: Union[Path, StreamType], *, transform: Any = ...
    ) -> Any: ...
    def Xdump_all(self, documents: Any, stream: Any, *, transform: Any = ...) -> Any:
        """
        Serialize a sequence of Python objects into a YAML stream.
        """
        ...

    def get_serializer_representer_emitter(self, stream: StreamType, tlca: Any) -> Any:
        class XDumper(CEmitter, self.Representer, rslvr): ...

    def map(self, **kw: Any) -> Any: ...
    def seq(self, *args: Any) -> Any: ...
    def official_plug_ins(self) -> Any:
        """Search for list of subdirs that are plug-ins, if __file__ is not available, e.g.
        single file installers that are not properly emulating a file-system (issue 324)
        no plug-ins will be found. If any are packaged, you know which file that are
        and you can explicitly provide it during instantiation:
            yaml = ruamel.yaml.YAML(plug_ins=['ruamel/yaml/jinja2/__plug_in__'])
        """
        ...

    def register_class(self, cls: Any) -> Any:
        """
        register a class for dumping/loading
        - if it has attribute yaml_tag use that to register, else use class name
        - if it has methods to_yaml/from_yaml use those to dump/load else dump attributes
          as mapping
        """
        ...

    def __enter__(self) -> Any: ...
    def __exit__(
        self,
        typ: Optional[type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -> None: ...
    @property
    def version(self) -> Optional[tuple[int, int]]: ...
    @version.setter
    def version(self, val: VersionType) -> None: ...
    @property
    def tags(self) -> Any: ...
    @tags.setter
    def tags(self, val: Any) -> None: ...
    @property
    def indent(self) -> Any: ...
    @indent.setter
    def indent(self, val: Any) -> None: ...
    @property
    def block_seq_indent(self) -> Any: ...
    @block_seq_indent.setter
    def block_seq_indent(self, val: Any) -> None: ...
    def compact(self, seq_seq: Any = ..., seq_map: Any = ...) -> None: ...

class YAMLContextManager:
    def __init__(self, yaml: Any, transform: Any = ...) -> None: ...
    def teardown_output(self) -> None: ...
    def init_output(self, first_data: Any) -> None: ...
    def dump(self, data: Any) -> None: ...

def yaml_object(yml: Any) -> Any:
    """Decorator for classes that needs to dump/load objects
    The tag for such objects is taken from the class attribute yaml_tag (or the
    class name in lowercase in case unavailable)
    If methods to_yaml and/or from_yaml are available, these are called for dumping resp.
    loading, default routines (dumping a mapping of the attributes) used otherwise.
    """
    ...

def warn_deprecation(fun: Any, method: Any, arg: str = ...) -> None: ...
def error_deprecation(
    fun: Any, method: Any, arg: str = ..., comment: str = ...
) -> None: ...

_error_dep_arg = ...
_error_dep_comment = ...

def scan(stream: StreamTextType, Loader: Any = ...) -> Any:
    """
    Scan a YAML stream and produce scanning tokens.
    """
    ...

def parse(stream: StreamTextType, Loader: Any = ...) -> Any:
    """
    Parse a YAML stream and produce parsing events.
    """
    ...

def compose(stream: StreamTextType, Loader: Any = ...) -> Any:
    """
    Parse the first YAML document in a stream
    and produce the corresponding representation tree.
    """
    ...

def compose_all(stream: StreamTextType, Loader: Any = ...) -> Any:
    """
    Parse all YAML documents in a stream
    and produce corresponding representation trees.
    """
    ...

def load(
    stream: Any, Loader: Any = ..., version: Any = ..., preserve_quotes: Any = ...
) -> Any:
    """
    Parse the first YAML document in a stream
    and produce the corresponding Python object.
    """
    ...

def load_all(
    stream: Any, Loader: Any = ..., version: Any = ..., preserve_quotes: Any = ...
) -> Any:
    """
    Parse all YAML documents in a stream
    and produce corresponding Python objects.
    """
    ...

def safe_load(stream: StreamTextType, version: Optional[VersionType] = ...) -> Any:
    """
    Parse the first YAML document in a stream
    and produce the corresponding Python object.
    Resolve only basic YAML tags.
    """
    ...

def safe_load_all(stream: StreamTextType, version: Optional[VersionType] = ...) -> Any:
    """
    Parse all YAML documents in a stream
    and produce corresponding Python objects.
    Resolve only basic YAML tags.
    """
    ...

def round_trip_load(
    stream: StreamTextType,
    version: Optional[VersionType] = ...,
    preserve_quotes: Optional[bool] = ...,
) -> Any:
    """
    Parse the first YAML document in a stream
    and produce the corresponding Python object.
    Resolve only basic YAML tags.
    """
    ...

def round_trip_load_all(
    stream: StreamTextType,
    version: Optional[VersionType] = ...,
    preserve_quotes: Optional[bool] = ...,
) -> Any:
    """
    Parse all YAML documents in a stream
    and produce corresponding Python objects.
    Resolve only basic YAML tags.
    """
    ...

def emit(
    events: Any,
    stream: Optional[StreamType] = ...,
    Dumper: Any = ...,
    canonical: Optional[bool] = ...,
    indent: Union[int, None] = ...,
    width: Optional[int] = ...,
    allow_unicode: Optional[bool] = ...,
    line_break: Any = ...,
) -> Any:
    """
    Emit YAML parsing events into a stream.
    If stream is None, return the produced string instead.
    """
    ...

enc = ...

def serialize_all(
    nodes: Any,
    stream: Optional[StreamType] = ...,
    Dumper: Any = ...,
    canonical: Any = ...,
    indent: Optional[int] = ...,
    width: Optional[int] = ...,
    allow_unicode: Optional[bool] = ...,
    line_break: Any = ...,
    encoding: Any = ...,
    explicit_start: Optional[bool] = ...,
    explicit_end: Optional[bool] = ...,
    version: Optional[VersionType] = ...,
    tags: Any = ...,
) -> Any:
    """
    Serialize a sequence of representation trees into a YAML stream.
    If stream is None, return the produced string instead.
    """
    ...

def serialize(
    node: Any, stream: Optional[StreamType] = ..., Dumper: Any = ..., **kwds: Any
) -> Any:
    """
    Serialize a representation tree into a YAML stream.
    If stream is None, return the produced string instead.
    """
    ...

def dump_all(
    documents: Any,
    stream: Optional[StreamType] = ...,
    Dumper: Any = ...,
    default_style: Any = ...,
    default_flow_style: Any = ...,
    canonical: Optional[bool] = ...,
    indent: Optional[int] = ...,
    width: Optional[int] = ...,
    allow_unicode: Optional[bool] = ...,
    line_break: Any = ...,
    encoding: Any = ...,
    explicit_start: Optional[bool] = ...,
    explicit_end: Optional[bool] = ...,
    version: Any = ...,
    tags: Any = ...,
    block_seq_indent: Any = ...,
    top_level_colon_align: Any = ...,
    prefix_colon: Any = ...,
) -> Any:
    """
    Serialize a sequence of Python objects into a YAML stream.
    If stream is None, return the produced string instead.
    """
    ...

def dump(
    data: Any,
    stream: Optional[StreamType] = ...,
    Dumper: Any = ...,
    default_style: Any = ...,
    default_flow_style: Any = ...,
    canonical: Optional[bool] = ...,
    indent: Optional[int] = ...,
    width: Optional[int] = ...,
    allow_unicode: Optional[bool] = ...,
    line_break: Any = ...,
    encoding: Any = ...,
    explicit_start: Optional[bool] = ...,
    explicit_end: Optional[bool] = ...,
    version: Optional[VersionType] = ...,
    tags: Any = ...,
    block_seq_indent: Any = ...,
) -> Any:
    """
    Serialize a Python object into a YAML stream.
    If stream is None, return the produced string instead.

    default_style ∈ None, '', '"', "'", '|', '>'

    """
    ...

def safe_dump(data: Any, stream: Optional[StreamType] = ..., **kwds: Any) -> Any:
    """
    Serialize a Python object into a YAML stream.
    Produce only basic YAML tags.
    If stream is None, return the produced string instead.
    """
    ...

def round_trip_dump(
    data: Any,
    stream: Optional[StreamType] = ...,
    Dumper: Any = ...,
    default_style: Any = ...,
    default_flow_style: Any = ...,
    canonical: Optional[bool] = ...,
    indent: Optional[int] = ...,
    width: Optional[int] = ...,
    allow_unicode: Optional[bool] = ...,
    line_break: Any = ...,
    encoding: Any = ...,
    explicit_start: Optional[bool] = ...,
    explicit_end: Optional[bool] = ...,
    version: Optional[VersionType] = ...,
    tags: Any = ...,
    block_seq_indent: Any = ...,
    top_level_colon_align: Any = ...,
    prefix_colon: Any = ...,
) -> Any: ...
def add_implicit_resolver(
    tag: Any,
    regexp: Any,
    first: Any = ...,
    Loader: Any = ...,
    Dumper: Any = ...,
    resolver: Any = ...,
) -> None:
    """
    Add an implicit scalar detector.
    If an implicit scalar value matches the given regexp,
    the corresponding tag is assigned to the scalar.
    first is a sequence of possible initial characters or None.
    """
    ...

def add_path_resolver(
    tag: Any,
    path: Any,
    kind: Any = ...,
    Loader: Any = ...,
    Dumper: Any = ...,
    resolver: Any = ...,
) -> None:
    """
    Add a path based resolver for the given tag.
    A path is a list of keys that forms a path
    to a node in the representation tree.
    Keys can be string values, integers, or None.
    """
    ...

def add_constructor(
    tag: Any, object_constructor: Any, Loader: Any = ..., constructor: Any = ...
) -> None:
    """
    Add an object constructor for the given tag.
    object_onstructor is a function that accepts a Loader instance
    and a node object and produces the corresponding Python object.
    """
    ...

def add_multi_constructor(
    tag_prefix: Any, multi_constructor: Any, Loader: Any = ..., constructor: Any = ...
) -> None:
    """
    Add a multi-constructor for the given tag prefix.
    Multi-constructor is called for a node if its tag starts with tag_prefix.
    Multi-constructor accepts a Loader instance, a tag suffix,
    and a node object and produces the corresponding Python object.
    """
    ...

def add_representer(
    data_type: Any, object_representer: Any, Dumper: Any = ..., representer: Any = ...
) -> None:
    """
    Add a representer for the given type.
    object_representer is a function accepting a Dumper instance
    and an instance of the given data type
    and producing the corresponding representation node.
    """
    ...

def add_multi_representer(
    data_type: Any, multi_representer: Any, Dumper: Any = ..., representer: Any = ...
) -> None:
    """
    Add a representer for the given type.
    multi_representer is a function accepting a Dumper instance
    and an instance of the given data type or subtype
    and producing the corresponding representation node.
    """
    ...

class YAMLObjectMetaclass(type):
    """
    The metaclass for YAMLObject.
    """

    def __init__(cls, name: Any, bases: Any, kwds: Any) -> None: ...

class YAMLObject(with_metaclass(YAMLObjectMetaclass)):
    """
    An object that can dump itself to a YAML stream
    and load itself from a YAML stream.
    """

    __slots__ = ...
    yaml_constructor = Constructor
    yaml_representer = Representer
    yaml_tag: Any = ...
    yaml_flow_style: Any = ...
    @classmethod
    def from_yaml(cls, constructor: Any, node: Any) -> Any:
        """
        Convert a representation node to a Python object.
        """
        ...

    @classmethod
    def to_yaml(cls, representer: Any, data: Any) -> Any:
        """
        Convert a Python object to a representation node.
        """
        ...
