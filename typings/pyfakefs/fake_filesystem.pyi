"""
This type stub file was generated by pyright.
"""

import os
import sys
from enum import Enum
from typing import Any, AnyStr, Callable, Dict, List, NoReturn, Optional, Tuple, Union

from pyfakefs.fake_file import AnyFile, AnyFileWrapper, FakeFile
from pyfakefs.helpers import AnyPath, AnyString

"""A fake filesystem implementation for unit testing.

:Usage:

>>> from pyfakefs import fake_filesystem, fake_os
>>> filesystem = fake_filesystem.FakeFilesystem()
>>> os_module = fake_os.FakeOsModule(filesystem)
>>> pathname = '/a/new/dir/new-file'

Create a new file object, creating parent directory objects as needed:

>>> os_module.path.exists(pathname)
False
>>> new_file = filesystem.create_file(pathname)

File objects can't be overwritten:

>>> os_module.path.exists(pathname)
True
>>> try:
...   filesystem.create_file(pathname)
... except OSError as e:
...   assert e.errno == errno.EEXIST, 'unexpected errno: %d' % e.errno
...   assert e.strerror == 'File exists in the fake filesystem'

Remove a file object:

>>> filesystem.remove_object(pathname)
>>> os_module.path.exists(pathname)
False

Create a new file object at the previous path:

>>> beatles_file = filesystem.create_file(pathname,
...     contents='Dear Prudence\\nWon\\'t you come out to play?\\n')
>>> os_module.path.exists(pathname)
True

Use the FakeFileOpen class to read fake file objects:

>>> file_module = fake_filesystem.FakeFileOpen(filesystem)
>>> for line in file_module(pathname):
...     print(line.rstrip())
...
Dear Prudence
Won't you come out to play?

File objects cannot be treated like directory objects:

>>> try:
...   os_module.listdir(pathname)
... except OSError as e:
...   assert e.errno == errno.ENOTDIR, 'unexpected errno: %d' % e.errno
...   assert e.strerror == 'Not a directory in the fake filesystem'

The FakeOsModule can list fake directory objects:

>>> os_module.listdir(os_module.path.dirname(pathname))
['new-file']

The FakeOsModule also supports stat operations:

>>> import stat
>>> stat.S_ISREG(os_module.stat(pathname).st_mode)
True
>>> stat.S_ISDIR(os_module.stat(os_module.path.dirname(pathname)).st_mode)
True
"""
if sys.platform.startswith("linux"):
    _MAX_LINK_DEPTH = ...
else:
    _MAX_LINK_DEPTH = ...

class OSType(Enum):
    """Defines the real or simulated OS of the underlying file system."""

    LINUX = ...
    MACOS = ...
    WINDOWS = ...

FakeNullFile = ...
FakeFileFromRealFile = ...
FakeDirectory = ...
FakeDirectoryFromRealDirectory = ...
FakeFileWrapper = ...
StandardStreamWrapper = ...
FakeDirWrapper = ...
FakePipeWrapper = ...
FakePathModule = ...
FakeOsModule = ...
FakeFileOpen = ...
FakeIoModule = ...
if sys.platform != "win32":
    FakeFcntlModule = ...
PatchMode = ...
is_root = ...
set_uid = ...
set_gid = ...
reset_ids = ...

class FakeFilesystem:
    """Provides the appearance of a real directory tree for unit testing.

    Attributes:
        path_separator: The path separator, corresponds to `os.path.sep`.
        alternative_path_separator: Corresponds to `os.path.altsep`.
        is_windows_fs: `True` in a real or faked Windows file system.
        is_macos: `True` under MacOS, or if we are faking it.
        is_case_sensitive: `True` if a case-sensitive file system is assumed.
        root: The root :py:class:`FakeDirectory` entry of the file system.
        umask: The umask used for newly created files, see `os.umask`.
        patcher: Holds the Patcher object if created from it. Allows access
            to the patcher object if using the pytest fs fixture.
        patch_open_code: Defines how `io.open_code` will be patched;
            patching can be on, off, or in automatic mode.
        shuffle_listdir_results: If `True`, `os.listdir` will not sort the
            results to match the real file system behavior.
    """

    def __init__(
        self,
        path_separator: str = ...,
        total_size: Optional[int] = ...,
        patcher: Any = ...,
    ) -> None:
        """
        Args:
            path_separator:  optional substitute for os.path.sep
            total_size: if not None, the total size in bytes of the
                root filesystem.

        Example usage to use the same path separator under all systems:

        >>> filesystem = FakeFilesystem(path_separator='/')

        """
        ...
    @property
    def is_linux(self) -> bool: ...
    @property
    def is_windows_fs(self) -> bool: ...
    @is_windows_fs.setter
    def is_windows_fs(self, value: bool) -> None: ...
    @property
    def is_macos(self) -> bool: ...
    @is_macos.setter
    def is_macos(self, value: bool) -> None: ...
    @property
    def cwd(self) -> str:
        """Return the current working directory of the fake filesystem."""
        ...
    @cwd.setter
    def cwd(self, value: str) -> None:
        """Set the current working directory of the fake filesystem.
        Make sure a new drive or share is auto-mounted under Windows.
        """
        ...
    @property
    def root_dir(self) -> FakeDirectory:
        """Return the root directory, which represents "/" under POSIX,
        and the current drive under Windows."""
        ...
    @property
    def root_dir_name(self) -> str:
        """Return the root directory name, which is "/" under POSIX,
        and the root path of the current drive under Windows."""
        ...
    @property
    def os(self) -> OSType:
        """Return the real or simulated type of operating system."""
        ...
    @os.setter
    def os(self, value: OSType) -> None:
        """Set the simulated type of operating system underlying the fake
        file system."""
        ...
    def reset(self, total_size: Optional[int] = ...):  # -> None:
        """Remove all file system contents and reset the root."""
        ...
    def pause(self) -> None:
        """Pause the patching of the file system modules until `resume` is
        called. After that call, all file system calls are executed in the
        real file system.
        Calling pause() twice is silently ignored.
        Only allowed if the file system object was created by a
        Patcher object. This is also the case for the pytest `fs` fixture.

        Raises:
            RuntimeError: if the file system was not created by a Patcher.
        """
        ...
    def resume(self) -> None:
        """Resume the patching of the file system modules if `pause` has
        been called before. After that call, all file system calls are
        executed in the fake file system.
        Does nothing if patching is not paused.
        Raises:
            RuntimeError: if the file system has not been created by `Patcher`.
        """
        ...
    def clear_cache(self) -> None:
        """Clear the cache of non-patched modules."""
        ...
    def line_separator(self) -> str: ...
    def raise_os_error(
        self,
        err_no: int,
        filename: Optional[AnyString] = ...,
        winerror: Optional[int] = ...,
    ) -> NoReturn:
        """Raises OSError.
        The error message is constructed from the given error code and shall
        start with the error string issued in the real system.
        Note: this is not true under Windows if winerror is given - in this
        case a localized message specific to winerror will be shown in the
        real file system.

        Args:
            err_no: A numeric error code from the C variable errno.
            filename: The name of the affected file, if any.
            winerror: Windows only - the specific Windows error code.
        """
        ...
    def get_path_separator(self, path: AnyStr) -> AnyStr:
        """Return the path separator as the same type as path"""
        ...
    def starts_with_sep(self, path: AnyStr) -> bool:
        """Return True if path starts with a path separator."""
        ...
    def add_mount_point(
        self, path: AnyStr, total_size: Optional[int] = ..., can_exist: bool = ...
    ) -> Dict:
        """Add a new mount point for a filesystem device.
        The mount point gets a new unique device number.

        Args:
            path: The root path for the new mount path.

            total_size: The new total size of the added filesystem device
                in bytes. Defaults to infinite size.

            can_exist: If True, no error is raised if the mount point
                already exists

        Returns:
            The newly created mount point dict.

        Raises:
            OSError: if trying to mount an existing mount point again,
                and `can_exist` is False.
        """
        ...
    def get_disk_usage(self, path: Optional[AnyStr] = ...) -> Tuple[int, int, int]:
        """Return the total, used and free disk space in bytes as named tuple,
        or placeholder values simulating unlimited space if not set.

        .. note:: This matches the return value of shutil.disk_usage().

        Args:
            path: The disk space is returned for the file system device where
                `path` resides.
                Defaults to the root path (e.g. '/' on Unix systems).
        """
        ...
    def set_disk_usage(self, total_size: int, path: Optional[AnyStr] = ...) -> None:
        """Changes the total size of the file system, preserving the
        used space.
        Example usage: set the size of an auto-mounted Windows drive.

        Args:
            total_size: The new total size of the filesystem in bytes.

            path: The disk space is changed for the file system device where
                `path` resides.
                Defaults to the root path (e.g. '/' on Unix systems).

        Raises:
            OSError: if the new space is smaller than the used size.
        """
        ...
    def change_disk_usage(
        self, usage_change: int, file_path: AnyStr, st_dev: int
    ) -> None:
        """Change the used disk space by the given amount.

        Args:
            usage_change: Number of bytes added to the used space.
                If negative, the used space will be decreased.

            file_path: The path of the object needing the disk space.

            st_dev: The device ID for the respective file system.

        Raises:
            OSError: if usage_change exceeds the free file system space
        """
        ...
    def stat(self, entry_path: AnyStr, follow_symlinks: bool = ...):
        """Return the os.stat-like tuple for the FakeFile object of entry_path.

        Args:
            entry_path:  Path to filesystem object to retrieve.
            follow_symlinks: If False and entry_path points to a symlink,
                the link itself is inspected instead of the linked object.

        Returns:
            The FakeStatResult object corresponding to entry_path.

        Raises:
            OSError: if the filesystem object doesn't exist.
        """
        ...
    def raise_for_filepath_ending_with_separator(
        self,
        entry_path: AnyStr,
        file_object: FakeFile,
        follow_symlinks: bool = ...,
        macos_handling: bool = ...,
    ) -> None: ...
    def chmod(
        self,
        path: AnyStr,
        mode: int,
        follow_symlinks: bool = ...,
        force_unix_mode: bool = ...,
    ) -> None:
        """Change the permissions of a file as encoded in integer mode.

        Args:
            path: (str) Path to the file.
            mode: (int) Permissions.
            follow_symlinks: If `False` and `path` points to a symlink,
                the link itself is affected instead of the linked object.
            force_unix_mode: if True and run under Windows, the mode is not
                adapted for Windows to allow making dirs unreadable
        """
        ...
    def utime(
        self,
        path: AnyStr,
        times: Optional[Tuple[Union[int, float], Union[int, float]]] = ...,
        *,
        ns: Optional[Tuple[int, int]] = ...,
        follow_symlinks: bool = ...
    ) -> None:
        """Change the access and modified times of a file.

        Args:
            path: (str) Path to the file.
            times: 2-tuple of int or float numbers, of the form (atime, mtime)
                which is used to set the access and modified times in seconds.
                If None, both times are set to the current time.
            ns: 2-tuple of int numbers, of the form (atime, mtime)  which is
                used to set the access and modified times in nanoseconds.
                If `None`, both times are set to the current time.
            follow_symlinks: If `False` and entry_path points to a symlink,
                the link itself is queried instead of the linked object.

            Raises:
                TypeError: If anything other than the expected types is
                    specified in the passed `times` or `ns` tuple,
                    or if the tuple length is not equal to 2.
                ValueError: If both times and ns are specified.
        """
        ...
    def get_open_file(self, file_des: int) -> AnyFileWrapper:
        """Return an open file.

        Args:
            file_des: File descriptor of the open file.

        Raises:
            OSError: an invalid file descriptor.
            TypeError: filedes is not an integer.

        Returns:
            Open file object.
        """
        ...
    def has_open_file(self, file_object: FakeFile) -> bool:
        """Return True if the given file object is in the list of open files.

        Args:
            file_object: The FakeFile object to be checked.

        Returns:
            `True` if the file is open.
        """
        ...
    def normcase(self, path: AnyStr) -> AnyStr:
        """Replace all appearances of alternative path separator
        with path separator.

        Do nothing if no alternative separator is set.

        Args:
            path: The path to be normalized.

        Returns:
            The normalized path that will be used internally.
        """
        ...
    def normpath(self, path: AnyStr) -> AnyStr:
        """Mimic os.path.normpath using the specified path_separator.

        Mimics os.path.normpath using the path_separator that was specified
        for this FakeFilesystem. Normalizes the path, but unlike the method
        absnormpath, does not make it absolute.  Eliminates dot components
        (. and ..) and combines repeated path separators (//).  Initial ..
        components are left in place for relative paths.
        If the result is an empty path, '.' is returned instead.

        This also replaces alternative path separator with path separator.
        That is, it behaves like the real os.path.normpath on Windows if
        initialized with '\\' as path separator and  '/' as alternative
        separator.

        Args:
            path:  (str) The path to normalize.

        Returns:
            (str) A copy of path with empty components and dot components
            removed.
        """
        ...
    def absnormpath(self, path: AnyStr) -> AnyStr:
        """Absolutize and minimalize the given path.

        Forces all relative paths to be absolute, and normalizes the path to
        eliminate dot and empty components.

        Args:
            path:  Path to normalize.

        Returns:
            The normalized path relative to the current working directory,
            or the root directory if path is empty.
        """
        ...
    def splitpath(self, path: AnyStr) -> Tuple[AnyStr, AnyStr]:
        """Mimic os.path.split using the specified path_separator.

        Mimics os.path.split using the path_separator that was specified
        for this FakeFilesystem.

        Args:
            path:  (str) The path to split.

        Returns:
            (str) A duple (pathname, basename) for which pathname does not
            end with a slash, and basename does not contain a slash.
        """
        ...
    def splitdrive(self, path: AnyStr) -> Tuple[AnyStr, AnyStr]:
        """Splits the path into the drive part and the rest of the path.

        Taken from Windows specific implementation in Python 3.5
        and slightly adapted.

        Args:
            path: the full path to be splitpath.

        Returns:
            A tuple of the drive part and the rest of the path, or of
            an empty string and the full path if drive letters are
            not supported or no drive is present.
        """
        ...
    def splitroot(
        self, path: AnyStr
    ):  # -> tuple[bytes* | str*, Literal[b"", ''], Literal[b"", '']] | tuple[bytes* | str*, bytes* | str*, bytes* | str*] | tuple[Literal[b"", ''], bytes* | str*, bytes* | str*] | tuple[bytes* | str*, Literal[b"", ''], bytes* | str*] | tuple[Literal[b"", ''], Literal[b"", ''], bytes* | str*] | tuple[Literal[b"", ''], bytes | str, bytes* | str*]:
        """Split a pathname into drive, root and tail.
        Implementation taken from ntpath and posixpath.
        """
        ...
    def joinpaths(self, *paths: AnyStr) -> AnyStr:
        """Mimic os.path.join using the specified path_separator.

        Args:
            *paths:  (str) Zero or more paths to join.

        Returns:
            (str) The paths joined by the path separator, starting with
            the last absolute path in paths.
        """
        ...
    def starts_with_drive_letter(self, file_path: AnyStr) -> bool:
        """Return True if file_path starts with a drive letter.

        Args:
            file_path: the full path to be examined.

        Returns:
            `True` if drive letter support is enabled in the filesystem and
            the path starts with a drive letter.
        """
        ...
    def replace_windows_root(self, path: AnyStr) -> AnyStr:
        """In windows, if a path starts with a single separator,
        it points to the root dir of the current mount point, usually a
        drive - replace it with that mount point path to get the real path.
        """
        ...
    def is_mount_point(self, file_path: AnyStr) -> bool:
        """Return `True` if `file_path` points to a mount point."""
        ...
    def ends_with_path_separator(self, path: Union[int, AnyPath]) -> bool:
        """Return True if ``file_path`` ends with a valid path separator."""
        ...
    def is_filepath_ending_with_separator(self, path: AnyStr) -> bool: ...
    def exists(self, file_path: AnyPath, check_link: bool = ...) -> bool:
        """Return true if a path points to an existing file system object.

        Args:
            file_path:  The path to examine.
            check_link: If True, links are not followed

        Returns:
            (bool) True if the corresponding object exists.

        Raises:
            TypeError: if file_path is None.
        """
        ...
    def resolve_path(self, file_path: AnyStr, allow_fd: bool = ...) -> AnyStr:
        """Follow a path, resolving symlinks.

        ResolvePath traverses the filesystem along the specified file path,
        resolving file names and symbolic links until all elements of the path
        are exhausted, or we reach a file which does not exist.
        If all the elements are not consumed, they just get appended to the
        path resolved so far.
        This gives us the path which is as resolved as it can be, even if the
        file does not exist.

        This behavior mimics Unix semantics, and is best shown by example.
        Given a file system that looks like this:

              /a/b/
              /a/b/c -> /a/b2          c is a symlink to /a/b2
              /a/b2/x
              /a/c   -> ../d
              /a/x   -> y

         Then:
              /a/b/x      =>  /a/b/x
              /a/c        =>  /a/d
              /a/x        =>  /a/y
              /a/b/c/d/e  =>  /a/b2/d/e

        Args:
            file_path: The path to examine.
            allow_fd: If `True`, `file_path` may be open file descriptor.

        Returns:
            The resolved_path (str or byte).

        Raises:
            TypeError: if `file_path` is `None`.
            OSError: if `file_path` is '' or a part of the path doesn't exist.
        """
        ...
    def get_object_from_normpath(
        self, file_path: AnyPath, check_read_perm: bool = ..., check_owner: bool = ...
    ) -> AnyFile:
        """Search for the specified filesystem object within the fake
        filesystem.

        Args:
            file_path: Specifies target FakeFile object to retrieve, with a
                path that has already been normalized/resolved.
            check_read_perm: If True, raises OSError if a parent directory
                does not have read permission
            check_owner: If True, and check_read_perm is also True,
                only checks read permission if the current user id is
                different from the file object user id

        Returns:
            The FakeFile object corresponding to file_path.

        Raises:
            OSError: if the object is not found.
        """
        ...
    def get_object(self, file_path: AnyPath, check_read_perm: bool = ...) -> FakeFile:
        """Search for the specified filesystem object within the fake
        filesystem.

        Args:
            file_path: Specifies the target FakeFile object to retrieve.
            check_read_perm: If True, raises OSError if a parent directory
                does not have read permission

        Returns:
            The FakeFile object corresponding to `file_path`.

        Raises:
            OSError: if the object is not found.
        """
        ...
    def resolve(
        self,
        file_path: AnyStr,
        follow_symlinks: bool = ...,
        allow_fd: bool = ...,
        check_read_perm: bool = ...,
        check_owner: bool = ...,
    ) -> FakeFile:
        """Search for the specified filesystem object, resolving all links.

        Args:
            file_path: Specifies the target FakeFile object to retrieve.
            follow_symlinks: If `False`, the link itself is resolved,
                otherwise the object linked to.
            allow_fd: If `True`, `file_path` may be an open file descriptor
            check_read_perm: If True, raises OSError if a parent directory
                does not have read permission
            check_owner: If True, and check_read_perm is also True,
                only checks read permission if the current user id is
                different from the file object user id

        Returns:
          The FakeFile object corresponding to `file_path`.

        Raises:
            OSError: if the object is not found.
        """
        ...
    def lresolve(self, path: AnyPath) -> FakeFile:
        """Search for the specified object, resolving only parent links.

        This is analogous to the stat/lstat difference.  This resolves links
        *to* the object but not of the final object itself.

        Args:
            path: Specifies target FakeFile object to retrieve.

        Returns:
            The FakeFile object corresponding to path.

        Raises:
            OSError: if the object is not found.
        """
        ...
    def add_object(self, file_path: AnyStr, file_object: AnyFile) -> None:
        """Add a fake file or directory into the filesystem at file_path.

        Args:
            file_path: The path to the file to be added relative to self.
            file_object: File or directory to add.

        Raises:
            OSError: if file_path does not correspond to a
                directory.
        """
        ...
    def rename(
        self, old_file_path: AnyPath, new_file_path: AnyPath, force_replace: bool = ...
    ) -> None:
        """Renames a FakeFile object at old_file_path to new_file_path,
        preserving all properties.

        Args:
            old_file_path: Path to filesystem object to rename.
            new_file_path: Path to where the filesystem object will live
                after this call.
            force_replace: If set and destination is an existing file, it
                will be replaced even under Windows if the user has
                permissions, otherwise replacement happens under Unix only.

        Raises:
            OSError: if old_file_path does not exist.
            OSError: if new_file_path is an existing directory
                (Windows, or Posix if old_file_path points to a regular file)
            OSError: if old_file_path is a directory and new_file_path a file
            OSError: if new_file_path is an existing file and force_replace
                not set (Windows only).
            OSError: if new_file_path is an existing file and could not be
                removed (Posix, or Windows with force_replace set).
            OSError: if dirname(new_file_path) does not exist.
            OSError: if the file would be moved to another filesystem
                (e.g. mount point).
        """
        ...
    def remove_object(self, file_path: AnyStr) -> None:
        """Remove an existing file or directory.

        Args:
            file_path: The path to the file relative to self.

        Raises:
            OSError: if file_path does not correspond to an existing file, or
                if part of the path refers to something other than a directory.
            OSError: if the directory is in use (eg, if it is '/').
        """
        ...
    def make_string_path(self, path: AnyPath) -> AnyStr: ...
    def create_dir(
        self, directory_path: AnyPath, perm_bits: int = ...
    ) -> FakeDirectory:
        """Create `directory_path`, and all the parent directories.

        Helper method to set up your test faster.

        Args:
            directory_path: The full directory path to create.
            perm_bits: The permission bits as set by `chmod`.

        Returns:
            The newly created FakeDirectory object.

        Raises:
            OSError: if the directory already exists.
        """
        ...
    def create_file(
        self,
        file_path: AnyPath,
        st_mode: int = ...,
        contents: AnyString = ...,
        st_size: Optional[int] = ...,
        create_missing_dirs: bool = ...,
        apply_umask: bool = ...,
        encoding: Optional[str] = ...,
        errors: Optional[str] = ...,
        side_effect: Optional[Callable] = ...,
    ) -> FakeFile:
        """Create `file_path`, including all the parent directories along
        the way.

        This helper method can be used to set up tests more easily.

        Args:
            file_path: The path to the file to create.
            st_mode: The stat constant representing the file type.
            contents: the contents of the file. If not given and st_size is
                None, an empty file is assumed.
            st_size: file size; only valid if contents not given. If given,
                the file is considered to be in "large file mode" and trying
                to read from or write to the file will result in an exception.
            create_missing_dirs: If `True`, auto create missing directories.
            apply_umask: `True` if the current umask must be applied
                on `st_mode`.
            encoding: If `contents` is a unicode string, the encoding used
                for serialization.
            errors: The error mode used for encoding/decoding errors.
            side_effect: function handle that is executed when file is written,
                must accept the file object as an argument.

        Returns:
            The newly created FakeFile object.

        Raises:
            OSError: if the file already exists.
            OSError: if the containing directory is required and missing.
        """
        ...
    def add_real_file(
        self,
        source_path: AnyPath[str],
        read_only: bool = ...,
        target_path: Optional[AnyPath[str]] = ...,
    ) -> FakeFile:
        """Create `file_path`, including all the parent directories along the
        way, for an existing real file. The contents of the real file are read
        only on demand.

        Args:
            source_path: Path to an existing file in the real file system
            read_only: If `True` (the default), writing to the fake file
                raises an exception.  Otherwise, writing to the file changes
                the fake file only.
            target_path: If given, the path of the target direction,
                otherwise it is equal to `source_path`.

        Returns:
            the newly created FakeFile object.

        Raises:
            OSError: if the file does not exist in the real file system.
            OSError: if the file already exists in the fake file system.

        .. note:: On most systems, accessing the fake file's contents may
            update both the real and fake files' `atime` (access time).
            In this particular case, `add_real_file()` violates the rule
            that `pyfakefs` must not modify the real file system.
        """
        ...
    def add_real_symlink(
        self, source_path: AnyPath, target_path: Optional[AnyPath] = ...
    ) -> FakeFile:
        """Create a symlink at source_path (or target_path, if given).  It will
        point to the same path as the symlink on the real filesystem.  Relative
        symlinks will point relative to their new location.  Absolute symlinks
        will point to the same, absolute path as on the real filesystem.

        Args:
            source_path: The path to the existing symlink.
            target_path: If given, the name of the symlink in the fake
                filesystem, otherwise, the same as `source_path`.

        Returns:
            the newly created FakeFile object.

        Raises:
            OSError: if the directory does not exist in the real file system.
            OSError: if the symlink could not be created
                (see :py:meth:`create_file`).
            OSError: if the directory already exists in the fake file system.
        """
        ...
    def add_real_directory(
        self,
        source_path: AnyPath,
        read_only: bool = ...,
        lazy_read: bool = ...,
        target_path: Optional[AnyPath] = ...,
    ) -> FakeDirectory:
        """Create a fake directory corresponding to the real directory at the
        specified path.  Add entries in the fake directory corresponding to
        the entries in the real directory.  Symlinks are supported.

        Args:
            source_path: The path to the existing directory.
            read_only: If set, all files under the directory are treated as
                read-only, e.g. a write access raises an exception;
                otherwise, writing to the files changes the fake files only
                as usually.
            lazy_read: If set (default), directory contents are only read when
                accessed, and only until the needed subdirectory level.

                .. note:: This means that the file system size is only updated
                  at the time the directory contents are read; set this to
                  `False` only if you are dependent on accurate file system
                  size in your test
            target_path: If given, the target directory, otherwise,
                the target directory is the same as `source_path`.

        Returns:
            the newly created FakeDirectory object.

        Raises:
            OSError: if the directory does not exist in the real file system.
            OSError: if the directory already exists in the fake file system.
        """
        ...
    def add_real_paths(
        self, path_list: List[AnyStr], read_only: bool = ..., lazy_dir_read: bool = ...
    ) -> None:
        """This convenience method adds multiple files and/or directories from
        the real file system to the fake file system. See `add_real_file()` and
        `add_real_directory()`.

        Args:
            path_list: List of file and directory paths in the real file
                system.
            read_only: If set, all files and files under under the directories
                are treated as read-only, e.g. a write access raises an
                exception; otherwise, writing to the files changes the fake
                files only as usually.
            lazy_dir_read: Uses lazy reading of directory contents if set
                (see `add_real_directory`)

        Raises:
            OSError: if any of the files and directories in the list
                does not exist in the real file system.
            OSError: if any of the files and directories in the list
                already exists in the fake file system.
        """
        ...
    def create_file_internally(
        self,
        file_path: AnyPath,
        st_mode: int = ...,
        contents: AnyString = ...,
        st_size: Optional[int] = ...,
        create_missing_dirs: bool = ...,
        apply_umask: bool = ...,
        encoding: Optional[str] = ...,
        errors: Optional[str] = ...,
        read_from_real_fs: bool = ...,
        side_effect: Optional[Callable] = ...,
    ) -> FakeFile:
        """Internal fake file creator that supports both normal fake files
        and fake files based on real files.

        Args:
            file_path: path to the file to create.
            st_mode: the stat.S_IF constant representing the file type.
            contents: the contents of the file. If not given and st_size is
                None, an empty file is assumed.
            st_size: file size; only valid if contents not given. If given,
                the file is considered to be in "large file mode" and trying
                to read from or write to the file will result in an exception.
            create_missing_dirs: if True, auto create missing directories.
            apply_umask: whether or not the current umask must be applied
                on st_mode.
            encoding: if contents is a unicode string, the encoding used for
                serialization.
            errors: the error mode used for encoding/decoding errors
            read_from_real_fs: if True, the contents are read from the real
                file system on demand.
            side_effect: function handle that is executed when file is written,
                must accept the file object as an argument.
        """
        ...
    def create_symlink(
        self, file_path: AnyPath, link_target: AnyPath, create_missing_dirs: bool = ...
    ) -> FakeFile:
        """Create the specified symlink, pointed at the specified link target.

        Args:
            file_path:  path to the symlink to create
            link_target:  the target of the symlink
            create_missing_dirs: If `True`, any missing parent directories of
                file_path will be created

        Returns:
            The newly created FakeFile object.

        Raises:
            OSError: if the symlink could not be created
                (see :py:meth:`create_file`).
        """
        ...
    def create_link(
        self,
        old_path: AnyPath,
        new_path: AnyPath,
        follow_symlinks: bool = ...,
        create_missing_dirs: bool = ...,
    ) -> FakeFile:
        """Create a hard link at new_path, pointing at old_path.

        Args:
            old_path: An existing link to the target file.
            new_path: The destination path to create a new link at.
            follow_symlinks: If False and old_path is a symlink, link the
                symlink instead of the object it points to.
            create_missing_dirs: If `True`, any missing parent directories of
                file_path will be created

        Returns:
            The FakeFile object referred to by old_path.

        Raises:
            OSError:  if something already exists at new_path.
            OSError:  if old_path is a directory.
            OSError:  if the parent directory doesn't exist.
        """
        ...
    def link(
        self, old_path: AnyPath, new_path: AnyPath, follow_symlinks: bool = ...
    ) -> FakeFile:
        """Create a hard link at new_path, pointing at old_path.

        Args:
            old_path: An existing link to the target file.
            new_path: The destination path to create a new link at.
            follow_symlinks: If False and old_path is a symlink, link the
                symlink instead of the object it points to.

        Returns:
            The FakeFile object referred to by old_path.

        Raises:
            OSError:  if something already exists at new_path.
            OSError:  if old_path is a directory.
            OSError:  if the parent directory doesn't exist.
        """
        ...
    def readlink(self, path: AnyPath) -> str:
        """Read the target of a symlink.

        Args:
            path:  symlink to read the target of.

        Returns:
            the string representing the path to which the symbolic link points.

        Raises:
            TypeError: if path is None
            OSError: (with errno=ENOENT) if path is not a valid path, or
                (with errno=EINVAL) if path is valid, but is not a symlink,
                or if the path ends with a path separator (Posix only)
        """
        ...
    def makedir(self, dir_path: AnyPath, mode: int = ...) -> None:
        """Create a leaf Fake directory.

        Args:
            dir_path: (str) Name of directory to create.
                Relative paths are assumed to be relative to '/'.
            mode: (int) Mode to create directory with.  This argument defaults
                to 0o777. The umask is applied to this mode.

        Raises:
            OSError: if the directory name is invalid or parent directory is
                read only or as per :py:meth:`add_object`.
        """
        ...
    def makedirs(self, dir_name: AnyStr, mode: int = ..., exist_ok: bool = ...) -> None:
        """Create a leaf Fake directory and create any non-existent
        parent dirs.

        Args:
            dir_name: (str) Name of directory to create.
            mode: (int) Mode to create directory (and any necessary parent
                directories) with. This argument defaults to 0o777.
                The umask is applied to this mode.
          exist_ok: (boolean) If exist_ok is False (the default), an OSError is
                raised if the target directory already exists.

        Raises:
            OSError: if the directory already exists and exist_ok=False,
                or as per :py:meth:`create_dir`.
        """
        ...
    def isdir(self, path: AnyPath, follow_symlinks: bool = ...) -> bool:
        """Determine if path identifies a directory.

        Args:
            path: Path to filesystem object.

        Returns:
            `True` if path points to a directory (following symlinks).

        Raises:
            TypeError: if path is None.
        """
        ...
    def isfile(self, path: AnyPath, follow_symlinks: bool = ...) -> bool:
        """Determine if path identifies a regular file.

        Args:
            path: Path to filesystem object.

        Returns:
            `True` if path points to a regular file (following symlinks).

        Raises:
            TypeError: if path is None.
        """
        ...
    def islink(self, path: AnyPath) -> bool:
        """Determine if path identifies a symbolic link.

        Args:
            path: Path to filesystem object.

        Returns:
            `True` if path points to a symlink (S_IFLNK set in st_mode)

        Raises:
            TypeError: if path is None.
        """
        ...
    if sys.version_info >= (3, 12): ...
    def confirmdir(
        self, target_directory: AnyStr, check_owner: bool = ...
    ) -> FakeDirectory:
        """Test that the target is actually a directory, raising OSError
        if not.

        Args:
            target_directory: Path to the target directory within the fake
                filesystem.
            check_owner: If True, only checks read permission if the current
                user id is different from the file object user id

        Returns:
            The FakeDirectory object corresponding to target_directory.

        Raises:
            OSError: if the target is not a directory.
        """
        ...
    def remove(self, path: AnyStr) -> None:
        """Remove the FakeFile object at the specified file path.

        Args:
            path: Path to file to be removed.

        Raises:
            OSError: if path points to a directory.
            OSError: if path does not exist.
            OSError: if removal failed.
        """
        ...
    def rmdir(self, target_directory: AnyStr, allow_symlink: bool = ...) -> None:
        """Remove a leaf Fake directory.

        Args:
            target_directory: (str) Name of directory to remove.
            allow_symlink: (bool) if `target_directory` is a symlink,
                the function just returns, otherwise it raises (Posix only)

        Raises:
            OSError: if target_directory does not exist.
            OSError: if target_directory does not point to a directory.
            OSError: if removal failed per FakeFilesystem.RemoveObject.
                Cannot remove '.'.
        """
        ...
    def listdir(self, target_directory: AnyStr) -> List[AnyStr]:
        """Return a list of file names in target_directory.

        Args:
            target_directory: Path to the target directory within the
                fake filesystem.

        Returns:
            A list of file names within the target directory in arbitrary
            order. If `shuffle_listdir_results` is set, the order is not the
            same in subsequent calls to avoid tests relying on any ordering.

        Raises:
            OSError: if the target is not a directory.
        """
        ...
    def __str__(self) -> str: ...

if __name__ == "__main__": ...
